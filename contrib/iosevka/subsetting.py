#!/usr/bin/env python
# /// script
# dependencies = [
#   "brotli~=1.1",
#   "fonttools~=4.53",
#   "rich~=14.0",
#   "textcase~=0.4.3",
#   "tqdm~=4.66",
#   "typer~=0.16.0",
# ]
# ///
"""
Facilitates the generation of subsetted fonts based on Iosevka custom web fonts
alongside corresponding CSS @font-face rules.

It operates by analyzing input font files (generated by vendor build script),
the unicode subsets configuration file, and font build plan details
to perform such tasks.
"""

from __future__ import annotations

import io
import itertools
import os
import re
import shutil
import subprocess
import textwrap
import tomllib
import warnings
from concurrent.futures import ProcessPoolExecutor, as_completed
from dataclasses import dataclass, field
from pathlib import Path  # noqa: TC003
from typing import TYPE_CHECKING, Annotated, Self

import textcase
import typer
from fontTools import unicodedata
from fontTools.ttLib import TTFont
from rich.console import Console
from rich.padding import Padding
from rich.rule import Rule
from rich.style import Style
from rich.text import Text
from tqdm import TqdmExperimentalWarning
from tqdm.rich import tqdm

if TYPE_CHECKING:
    from collections.abc import Iterable, Iterator

INFO = Style(color="gray74")
RULE = Rule(style="gray19")

warnings.filterwarnings("ignore", category=TqdmExperimentalWarning)
print = Console(stderr=True).print  # noqa: A001
typer_app = typer.Typer(
    add_completion=False,
    rich_markup_mode="markdown",
    pretty_exceptions_enable=False,
)


#  __  __       _         ____
# |  \/  | __ _(_)_ __   |  _ \ _ __ ___   __ _ _ __ __ _ _ __ ___
# | |\/| |/ _` | | '_ \  | |_) | '__/ _ \ / _` | '__/ _` | '_ ` _ \
# | |  | | (_| | | | | | |  __/| | | (_) | (_| | | | (_| | | | | | |
# |_|  |_|\__,_|_|_| |_| |_|   |_|  \___/ \__, |_|  \__,_|_| |_| |_|
#                                         |___/
@typer_app.command()
def program(
    input_dir: Annotated[
        Path,
        typer.Option(
            show_default=False,
            help="Where Iosevka *.woff2 font files are generated",
            exists=True,
            file_okay=False,
        ),
    ],
    output_dir: Annotated[
        Path,
        typer.Option(
            "--output-dir",
            "-o",
            show_default=False,
            help="Output directory to create subsetted fonts and CSS file",
            file_okay=False,
        ),
    ],
    css_font_base_url: Annotated[
        Path,
        typer.Option(
            show_default=False,
            help="Base directory of subsetted fonts that should appear in CSS file",
        ),
    ],
    build_plans: Annotated[
        Path,
        typer.Option(
            show_default=False,
            help="Path to `private-build-plans.toml` config file used by "
            "Iosevka vendor build script to generate original set of fonts",
            exists=True,
            dir_okay=False,
            rich_help_panel="Font Style Parsing Options",
        ),
    ],
    plan_name: Annotated[
        str,
        typer.Option(
            show_default=False,
            help="Name of the Iosevka font build plan as appeared in the "
            "`private-build-plans.toml` config file under the `buildPlans` section",
            rich_help_panel="Font Style Parsing Options",
        ),
    ],
    subsets_config: Annotated[
        Path,
        typer.Option(
            show_default=False,
            help="TOML file contain how fonts should be subsetted",
            exists=True,
            dir_okay=False,
            rich_help_panel="Unicode Subsetting Options",
        ),
    ],
    sample_font: Annotated[
        Path,
        typer.Option(
            show_default=False,
            help="Uses this font to obtain all Unicode code points "
            "representative of what is available in the current version of Iosevka",
            exists=True,
            dir_okay=False,
            rich_help_panel="Unicode Subsetting Options",
        ),
    ] = None,
    commit: Annotated[
        bool,
        typer.Option(
            "--commit/--dry-run",
            " /-n",
            help="Whether to commit changes to the output directory",
        ),
    ] = False,
    force: Annotated[
        bool,
        typer.Option(
            "--force",
            "-f",
            help="Force the generation of font subsets, even if the output directory already exists",
        ),
    ] = False,
):
    """
    Generates font subsets based on the original Iosevka custom web fonts,
    along with a CSS file containing @font-face rules.

    By default, output files will be listed but not generated (dry run).
    Use the `--commit` flag to actually generate the subsetted font files.
    """
    tasks_builder = TasksBuilder.from_program_args(
        output_dir=output_dir,
        css_font_base_url=css_font_base_url,
        build_plans=build_plans,
        plan_name=plan_name,
        subsets_config=subsets_config,
        sample_font=sample_font,
    )
    tasks_suite = tasks_builder.create_from_input_dir(input_dir)
    if commit:
        # If the output directory already exists,
        # we need to clear if (given the --force option is set)
        if output_dir.exists():
            if not force:
                raise error(
                    "Output directory already exists. "
                    "Please remove it first (or use `--force` to overwrite it)."
                )
            shutil.rmtree(output_dir)
        tasks_suite.run_css_tasks()
        tasks_suite.run_subset_tasks()
    else:
        # If we are in dry run mode, just print the tasks that would be run
        tasks_suite.dry_run()


# ▄▄▄█████▓ ▄▄▄        ██████  ██ ▄█▀    ██▀███   █    ██  ███▄    █  ███▄    █ ▓█████  ██▀███
# ▓  ██▒ ▓▒▒████▄    ▒██    ▒  ██▄█▒    ▓██ ▒ ██▒ ██  ▓██▒ ██ ▀█   █  ██ ▀█   █ ▓█   ▀ ▓██ ▒ ██▒
# ▒ ▓██░ ▒░▒██  ▀█▄  ░ ▓██▄   ▓███▄░    ▓██ ░▄█ ▒▓██  ▒██░▓██  ▀█ ██▒▓██  ▀█ ██▒▒███   ▓██ ░▄█ ▒
# ░ ▓██▓ ░ ░██▄▄▄▄██   ▒   ██▒▓██ █▄    ▒██▀▀█▄  ▓▓█  ░██░▓██▒  ▐▌██▒▓██▒  ▐▌██▒▒▓█  ▄ ▒██▀▀█▄
#   ▒██▒ ░  ▓█   ▓██▒▒██████▒▒▒██▒ █▄   ░██▓ ▒██▒▒▒█████▓ ▒██░   ▓██░▒██░   ▓██░░▒████▒░██▓ ▒██▒
#   ▒ ░░    ▒▒   ▓▒█░▒ ▒▓▒ ▒ ░▒ ▒▒ ▓▒   ░ ▒▓ ░▒▓░░▒▓▒ ▒ ▒ ░ ▒░   ▒ ▒ ░ ▒░   ▒ ▒ ░░ ▒░ ░░ ▒▓ ░▒▓░
#     ░      ▒   ▒▒ ░░ ░▒  ░ ░░ ░▒ ▒░     ░▒ ░ ▒░░░▒░ ░ ░ ░ ░░   ░ ▒░░ ░░   ░ ▒░ ░ ░  ░  ░▒ ░ ▒░
#   ░        ░   ▒   ░  ░  ░  ░ ░░ ░      ░░   ░  ░░░ ░ ░    ░   ░ ░    ░   ░ ░    ░     ░░   ░
#                ░  ░      ░  ░  ░         ░        ░              ░          ░    ░  ░   ░
#
#  _____         _        ____        _ _     _
# |_   _|_ _ ___| | _____| __ ) _   _(_) | __| | ___ _ __
#   | |/ _` / __| |/ / __|  _ \| | | | | |/ _` |/ _ \ '__|
#   | | (_| \__ \   <\__ \ |_) | |_| | | | (_| |  __/ |
#   |_|\__,_|___/_|\_\___/____/ \__,_|_|_|\__,_|\___|_|
#
@dataclass(frozen=True, kw_only=True)
class TasksBuilder:
    """
    A task builder for preparing a collection of font subset tasks
    based on the input font files and parameters from the program's input arguments.
    """

    output_dir: Path
    css_font_base_url: Path
    plan_name: str
    font_style_parser: FontStyleParser
    subsets_finder: SubsetsFinder

    @classmethod
    def from_program_args(
        cls,
        *,
        output_dir: Path,
        css_font_base_url: Path,
        build_plans: Path,
        plan_name: str,
        subsets_config: Path,
        sample_font: Path | None,
    ) -> Self:
        return cls(
            output_dir=output_dir,
            css_font_base_url=css_font_base_url,
            plan_name=plan_name,
            font_style_parser=FontStyleParser.from_build_plan(
                build_plans=build_plans,
                plan_name=plan_name,
            ),
            subsets_finder=SubsetsFinder.from_config(
                subsets_config=subsets_config, sample_font=sample_font
            ),
        )

    def create_from_input_dir(self, input_dir: Path) -> TasksSuite:
        tasks = []
        for input_font in input_dir.glob("*.woff2"):
            tasks.extend(self.create_from_input_font(input_font).tasks)
        tasks.sort(key=lambda task: task.css_values)
        return TasksSuite(builder=self, tasks=tasks)

    def create_from_input_font(self, input_font: Path) -> TasksSuite:
        css_values = self.font_style_parser.css_values(input_font.name)
        subsets = self.subsets_finder.compute_subsets(input_font)
        tasks = [
            FontSubsetTask(
                builder=self,
                input_font=input_font,
                css_values=css_values,
                subset=subset,
            )
            for subset in subsets
        ]
        return TasksSuite(builder=self, tasks=tasks)


#  _____         _        ____        _ _
# |_   _|_ _ ___| | _____/ ___| _   _(_) |_ ___
#   | |/ _` / __| |/ / __\___ \| | | | | __/ _ \
#   | | (_| \__ \   <\__ \___) | |_| | | ||  __/
#   |_|\__,_|___/_|\_\___/____/ \__,_|_|\__\___|
#
@dataclass(frozen=True, kw_only=True)
class TasksSuite:
    """
    A suite of tasks with methods to generate font subsets and CSS files,
    or to print a dry run summary of the tasks.
    """

    builder: TasksBuilder
    tasks: list[FontSubsetTask]

    def dry_run(self):
        """
        Prints a dry run summary of font subset tasks to standard error.
        The summary includes the input font files, the CSS values to be used,
        and a list of output files that would be generated for such input.
        """
        print("Dry run: list of input and output files to generate:", style=INFO)

        prev_input_font = None
        for task in self.tasks:
            # Print input font once for the group
            if task.input_font != prev_input_font:
                input_file = Text(os.fspath(task.input_font), style="blue")
                print(RULE)
                print(input_file)
                print(f"  {{ {task.css_values:css} }}")

            # Print the output file for the task
            output_file = Text(os.fspath(task.output_font), style="green")
            size = Text(f"({len(task.subset)})", style="dim")
            print(" ->", output_file, size)
            prev_input_font = task.input_font

        print(RULE)
        print("CSS file to generate:", self.output_css_file, style=INFO)
        print("Total:", len(self.tasks), "tasks to run.", style=INFO)

    def run_css_tasks(self):
        """
        Generates CSS @font-face rules for all tasks
        and writes them into a single CSS file.
        """
        print("Generating CSS file...", style=INFO)
        self.output_css_file.parent.mkdir(parents=True, exist_ok=True)
        with self.output_css_file.open("w") as f:
            for task in self.tasks:
                f.write(task.generate_css())
        print(Text("File created:", style="green"), self.output_css_file)

    def run_subset_tasks(self):
        """
        Executes a list of FontSubsetTask objects to generate font subsets.
        It uses a process pool to run the tasks concurrently.
        """
        print("Generating font subsets...", style=INFO)
        with ProcessPoolExecutor() as executor:
            futures = {executor.submit(task.build_subset): task for task in self.tasks}
            with tqdm(as_completed(futures), total=len(futures)) as progress_bar:
                for future in progress_bar:
                    output_file = futures[future].output_font
                    try:
                        future.result()
                        label = rich_string("File created:", style="green")
                        progress_bar.write(f"{label} {output_file}")
                    except Exception as exc:
                        label = rich_string("Error:", style="bold red")
                        progress_bar.write(f"{label}: while generating {output_file}: {exc}")

    @property
    def output_css_file(self) -> Path:
        return self.builder.output_dir / "font.css"


#  _____           _   ____        _              _  _____         _
# |  ___|__  _ __ | |_/ ___| _   _| |__  ___  ___| ||_   _|_ _ ___| | __
# | |_ / _ \| '_ \| __\___ \| | | | '_ \/ __|/ _ \ __|| |/ _` / __| |/ /
# |  _| (_) | | | | |_ ___) | |_| | |_) \__ \  __/ |_ | | (_| \__ \   <
# |_|  \___/|_| |_|\__|____/ \__,_|_.__/|___/\___|\__||_|\__,_|___/_|\_\
#
@dataclass(frozen=True, kw_only=True)
class FontSubsetTask:
    builder: TasksBuilder
    input_font: Path
    subset: UnicodeSubset
    css_values: CSSValues

    def build_subset(self):
        args = [
            "pyftsubset",
            os.fspath(self.input_font),
            f"--unicodes={self.subset:U+XXXX-XXXX,}",
            "--flavor=woff2",
            f"--output-file={os.fspath(self.output_font)}",
        ]
        self.output_font.parent.mkdir(parents=True, exist_ok=True)
        subprocess.run(args, capture_output=True, check=True)  # noqa: S603

    def generate_css(self) -> str:
        return textwrap.dedent(f"""\
            @font-face {{
              font-family: "{self.font_family}";
              font-display: swap;
              font-stretch: {self.css_values.width};
              font-weight: {self.css_values.weight};
              font-style: {self.css_values.slope};
              src: url("{self.css_font_path}") format("woff2");
              unicode-range: {self.subset:U+XXXX-XXXX,};
            }}
             
        """)

    @property
    def font_family(self) -> str:
        return textcase.title(self.builder.plan_name)

    @property
    def css_font_path(self) -> str:
        return os.fspath(self.builder.css_font_base_url / self.output_basename)

    @property
    def output_font(self) -> Path:
        return self.builder.output_dir / self.output_basename

    @property
    def output_basename(self) -> str:
        if self.subset.name is None:
            raise error("Subset name must be set before generating the output file.")
        return f"{self.input_font.stem}-{self.subset.name}.woff2"


#  █    ██  ███▄    █  ██▓ ▄████▄   ▒█████  ▓█████▄ ▓█████     █    ██ ▄▄▄█████▓ ██▓ ██▓      ██████
#  ██  ▓██▒ ██ ▀█   █ ▓██▒▒██▀ ▀█  ▒██▒  ██▒▒██▀ ██▌▓█   ▀     ██  ▓██▒▓  ██▒ ▓▒▓██▒▓██▒    ▒██    ▒
# ▓██  ▒██░▓██  ▀█ ██▒▒██▒▒▓█    ▄ ▒██░  ██▒░██   █▌▒███      ▓██  ▒██░▒ ▓██░ ▒░▒██▒▒██░    ░ ▓██▄
# ▓▓█  ░██░▓██▒  ▐▌██▒░██░▒▓▓▄ ▄██▒▒██   ██░░▓█▄   ▌▒▓█  ▄    ▓▓█  ░██░░ ▓██▓ ░ ░██░▒██░      ▒   ██▒
# ▒▒█████▓ ▒██░   ▓██░░██░▒ ▓███▀ ░░ ████▓▒░░▒████▓ ░▒████▒   ▒▒█████▓   ▒██▒ ░ ░██░░██████▒▒██████▒▒
# ░▒▓▒ ▒ ▒ ░ ▒░   ▒ ▒ ░▓  ░ ░▒ ▒  ░░ ▒░▒░▒░  ▒▒▓  ▒ ░░ ▒░ ░   ░▒▓▒ ▒ ▒   ▒ ░░   ░▓  ░ ▒░▓  ░▒ ▒▓▒ ▒ ░
# ░░▒░ ░ ░ ░ ░░   ░ ▒░ ▒ ░  ░  ▒     ░ ▒ ▒░  ░ ▒  ▒  ░ ░  ░   ░░▒░ ░ ░     ░     ▒ ░░ ░ ▒  ░░ ░▒  ░ ░
#  ░░░ ░ ░    ░   ░ ░  ▒ ░░        ░ ░ ░ ▒   ░ ░  ░    ░       ░░░ ░ ░   ░       ▒ ░  ░ ░   ░  ░  ░
#    ░              ░  ░  ░ ░          ░ ░     ░       ░  ░      ░               ░      ░  ░      ░
#                         ░                  ░
# Provides functionality to work with Unicode ranges and subsets.
#
UNICODE_RANGE_RE = re.compile(r'(?:u|U\+)?([0-9A-Fa-f]+)(?:(?:-|..)(?:u|U\+)?([0-9A-Fa-f]+))?')
UNICODE_FORMAT_SPEC_RE = re.compile(
    r"(?P<start_prefix>(?:u|U\+)?)XXXX"
    r"(?P<connector>-|..)"
    r"(?P<end_prefix>(?:u|U\+)?)XXXX"
    r"(?P<separator>[:;,\s]*)"
)


@dataclass(frozen=True, kw_only=True)
class SubsetsFinder:
    """
    Computes a list of Unicode subsets indicating how to subset a font file
    based on a pre-configured subsets file.

    However, if a sample font is provided at the beginning,
    it will be used to pre-compute the Unicode subsets
    and the actual input font file will be ignored.
    """

    subsets_config: Path
    subsets: list[UnicodeSubset] | None

    def compute_subsets(self, font_file: Path) -> list[UnicodeSubset]:
        return self.subsets or self._compute_subsets(
            config_file=self.subsets_config, font_file=font_file
        )

    @classmethod
    def from_config(cls, *, subsets_config: Path, sample_font: Path | None) -> Self:
        subsets = (
            cls._compute_subsets(config_file=subsets_config, font_file=sample_font)
            if subsets_config
            else None
        )
        return cls(subsets_config=subsets_config, subsets=subsets)

    @staticmethod
    def _compute_subsets(*, config_file: Path, font_file: Path) -> list[UnicodeSubset]:
        """
        Reads the pre-computed Unicode subsets from the ranks file
        and computes the subsets based on the provided font file.

        TODO: Refactor how subsets are structured in ranks file.
        """
        with config_file.open("rb") as f:
            data = tomllib.load(f)

        subsets = []

        common_unicodes = UnicodeSubset()
        for k, v in data["codepoints"]["common"].items():
            name = textcase.pascal(k)
            subset = UnicodeSubset.from_str(v)
            common_unicodes.update(subset)
            subsets.append(subset.with_name(name))

        handpicked_unicodes = UnicodeSubset()
        for k, v in data["codepoints"]["handpick"].items():
            name = textcase.pascal(k)
            subset = UnicodeSubset.from_str(v) - common_unicodes
            handpicked_unicodes.update(subset)
            subsets.append(subset.with_name(name))

        iosevka_unicodes = UnicodeSubset.from_font_file(font_file)
        subset = iosevka_unicodes.difference(common_unicodes, handpicked_unicodes)
        subsets.append(subset.with_name("Others"))

        return subsets

    # def validate_nonoverlapping_subsets(subsets: list[UnicodeSubset]) -> bool:
    #     return all(p.is_disjoint(q) for p, q in itertools.combinations(subsets, 2))


@dataclass(frozen=True, kw_only=True)
class UnicodeRange:
    """
    A contiguous range of Unicode code points.

    This class encapsulates a range of Unicode code points by its start and end code points.
    It provides methods to create a Unicode range from a string representation,
    iterate over the range, and format the range into a standard string format.

    The standard string format for a Unicode range has one of the following forms:
    - A single codepoint: `U+XXXX`, `uXXXX`, or simply `XXXX`.
    - A range of codepoints, which is two codepoints separated by a connector,
      where a connector can be a single hyphen '-' or two dots '..'.

    Examples of valid string formats (compatible with `format` function) include:
    "U+XXXX-XXXX", "uXXXX-uXXXX", "XXXX..XXXX", etc.
    """

    #: The starting Unicode code point in the range.
    start: int
    #: The ending Unicode code point in the range. It can be identical to `start`.
    end: int

    @classmethod
    def from_str(cls, s: str) -> Self:
        match = UNICODE_RANGE_RE.fullmatch(s.strip())
        if not match:
            raise ValueError(f"Invalid Unicode range format: {s}")
        start = int(match.group(1), 16)
        end = int(match.group(2), 16) if match.group(2) else start
        return cls(start=start, end=end)

    def __iter__(self) -> Iterator[int]:
        return iter(range(self.start, self.end + 1))

    def __format__(self, format_spec: str) -> str:
        match = UNICODE_FORMAT_SPEC_RE.fullmatch(format_spec)
        if not match:
            raise ValueError(f"Unrecognized format specifier: {format_spec!r}")
        if separator := match["separator"]:
            raise ValueError(f"Separator not allowed in format specifier: {separator!r}")
        return self.format_inner(match["start_prefix"], match["connector"], match["end_prefix"])

    def format_inner(self, start_prefix: str, connector: str, end_prefix: str) -> str:
        if self.start == self.end:
            return f"{start_prefix}{self.start:04X}"
        else:
            return f"{start_prefix}{self.start:04X}{connector}{end_prefix}{self.end:04X}"


@dataclass(kw_only=True)
class UnicodeSubset:
    """
    A subset of Unicode code points. Can be viewed as a collection of disjoint Unicode ranges.

    This class represents, manipulates, and queries subsets of Unicode characters.
    It works with Unicode code points, allowing for mathematical set operations
    such as union, intersection, and difference between subsets.

    Multiple constructures are provided to create an instance,
    such as from a string representation of Unicode ranges, or from a font file.
    """

    #: An optional name or identifier for the subset. Defaults to None.
    name: str | None = None
    #: A set containing Unicode code point integers representing the subset.
    charset: set[int] = field(default_factory=set)

    #   ___         _ _             __  __     _   _            _
    #  / __|___  __| (_)_ _  __ _  |  \/  |___| |_| |_  ___  __| |___
    # | (__/ _ \/ _` | | ' \/ _` | | |\/| / -_)  _| ' \/ _ \/ _` (_-<
    #  \___\___/\__,_|_|_||_\__, | |_|  |_\___|\__|_||_\___/\__,_/__/
    #                       |___/

    @classmethod
    def from_str(cls, s: str) -> Self:
        charset = set()
        for urange_str in s.split(","):
            urange = UnicodeRange.from_str(urange_str)
            charset.update(urange)
        return cls(charset=charset)

    @classmethod
    def from_font_file(cls, font_file: Path) -> Self:
        font = TTFont(os.fspath(font_file))
        return cls.from_font(font)

    @classmethod
    def from_font(cls, font: TTFont) -> Self:
        charset = {
            codepoint
            for table in font["cmap"].tables
            if table.isUnicode()
            for codepoint in table.cmap
        }
        return cls(charset=charset)

    def __format__(self, format_spec: str) -> str:
        match = UNICODE_FORMAT_SPEC_RE.fullmatch(format_spec)
        if not match and not match["separator"]:
            raise ValueError(f"Invalid format specifier: {format_spec}")

        start_prefix, connector, end_prefix = match.group(
            "start_prefix", "connector", "end_prefix"
        )
        return match["separator"].join(
            urange.format_inner(start_prefix, connector, end_prefix)
            for urange in self.sorted_uranges()
        )

    #  ___ _             __  __     _   _            _
    # |_ _| |_ ___ _ _  |  \/  |___| |_| |_  ___  __| |___
    #  | ||  _/ -_) '_| | |\/| / -_)  _| ' \/ _ \/ _` (_-<
    # |___|\__\___|_|   |_|  |_\___|\__|_||_\___/\__,_/__/
    #

    def sorted_uranges(self) -> Iterator[UnicodeRange]:
        if not self.charset:
            return
        charset = sorted(self.charset)
        urange_start = charset[0]
        for prev, curr in itertools.pairwise(charset):
            if curr > prev + 1:
                yield UnicodeRange(start=urange_start, end=prev)
                urange_start = curr
        yield UnicodeRange(start=urange_start, end=charset[-1])

    #  _  _                                    _
    # | \| |___ _ _ ___ ___ _ __  ___ _ _ __ _| |_ ___ _ _
    # | .` / _ \ ' \___/ _ \ '_ \/ -_) '_/ _` |  _/ _ \ '_|
    # |_|\_\___/_||_|  \___/ .__/\___|_| \__,_|\__\___/_|
    #  ___                 |_|      _    _       __  __     _   _            _
    # |_ _|_ __  _ __ _  _| |_ __ _| |__| |___  |  \/  |___| |_| |_  ___  __| |___
    #  | || '  \| '  \ || |  _/ _` | '_ \ / -_) | |\/| / -_)  _| ' \/ _ \/ _` (_-<
    # |___|_|_|_|_|_|_\_,_|\__\__,_|_.__/_\___| |_|  |_\___|\__|_||_\___/\__,_/__/
    #

    def print_debug(self):
        name = self.name if self.name else "<unknown>"
        count = len(self.charset)
        subset_str = Padding(Text(format(self, "U+XXXX-XXXX,")), pad=(0, 0, 0, 4), style="green")
        print(f"[bold]{name}[/] ({count}):", subset_str)

    def empty(self) -> bool:
        return not bool(self.charset)

    def is_disjoint(self, other) -> bool:
        return self.charset.isdisjoint(other.charset)

    def is_subset(self, other) -> bool:
        return self.charset.issubset(other)

    def is_superset(self, other) -> bool:
        return self.charset.issuperset(other)

    def union(self, *others: Iterable[int]) -> Self:
        new_subset = self.copy()
        new_subset.update(*others)
        return new_subset

    def intersection(self, *others: Iterable[int]) -> Self:
        new_subset = self.copy()
        new_subset.intersection_update(*others)
        return new_subset

    def difference(self, *others: Iterable[int]) -> Self:
        new_subset = self.copy()
        new_subset.difference_update(*others)
        return new_subset

    def copy(self) -> Self:
        return UnicodeSubset(charset=self.charset.copy())

    def with_name(self, name: str) -> Self:
        return UnicodeSubset(name=name, charset=self.charset.copy())

    def without_invalid(self) -> Self:
        """Return a new UnicodeRanges with only valid code points."""
        return UnicodeSubset({code for code in self.charset if self.check_valid(code)})

    #  _  _                                    _
    # | \| |___ _ _ ___ ___ _ __  ___ _ _ __ _| |_ ___ _ _
    # | .` / _ \ ' \___/ _ \ '_ \/ -_) '_/ _` |  _/ _ \ '_|
    # |_|\_\___/_||_|  \___/ .__/\___|_| \__,_|\__\___/_|
    #  __  __      _       |_|   _       __  __     _   _            _
    # |  \/  |_  _| |_ __ _| |__| |___  |  \/  |___| |_| |_  ___  __| |___
    # | |\/| | || |  _/ _` | '_ \ / -_) | |\/| / -_)  _| ' \/ _ \/ _` (_-<
    # |_|  |_|\_,_|\__\__,_|_.__/_\___| |_|  |_\___|\__|_||_\___/\__,_/__/
    #

    def add(self, code: int | str):
        code = self.ensure_code(code)
        if self.check_valid(code):
            self.charset.add(code)

    def remove(self, code: int | str):
        code = self.ensure_code(code)
        self.charset.remove(code)

    def discard(self, code: int | str):
        code = self.ensure_code(code)
        self.charset.discard(code)

    def update(self, *others: Iterable[int]):
        self.charset.update(*others)

    def intersection_update(self, *others: Iterable[int]):
        self.charset.intersection_update(*others)

    def difference_update(self, *others: Iterable[int]):
        self.charset.difference_update(*others)

    def clear_invalid(self):
        self.charset = {code for code in self.charset if self.check_valid(code)}

    #  ___ _        _   _      _  _     _                 __  __     _   _            _
    # / __| |_ __ _| |_(_)__  | || |___| |_ __  ___ _ _  |  \/  |___| |_| |_  ___  __| |___
    # \__ \  _/ _` |  _| / _| | __ / -_) | '_ \/ -_) '_| | |\/| / -_)  _| ' \/ _ \/ _` (_-<
    # |___/\__\__,_|\__|_\__| |_||_\___|_| .__/\___|_|   |_|  |_\___|\__|_||_\___/\__,_/__/
    #                                    |_|

    @staticmethod
    def ensure_code(code: int | str) -> int:
        """Ensure that the code is an integer codepoint."""
        if isinstance(code, str):
            return ord(code)
        elif isinstance(code, int):
            return code
        else:
            raise TypeError(f"code must be int or str, not {type(code).__name__}")

    @staticmethod
    def check_valid(code: int) -> bool:
        return bool(unicodedata.name(chr(code), None))

    #  __  __           _      ___               _           __  __     _   _            _
    # |  \/  |__ _ __ _(_)__  |   \ _  _ _ _  __| |___ _ _  |  \/  |___| |_| |_  ___  __| |___
    # | |\/| / _` / _` | / _| | |) | || | ' \/ _` / -_) '_| | |\/| / -_)  _| ' \/ _ \/ _` (_-<
    # |_|  |_\__,_\__, |_\__| |___/ \_,_|_||_\__,_\___|_|   |_|  |_\___|\__|_||_\___/\__,_/__/
    #             |___/

    def __repr__(self):
        s = format(self, "U+XXXX-XXXX,")
        if self.name is None:
            return f"{self.__class__.__name__}.from_str({s!r})"
        else:
            return f"{self.__class__.__name__}.from_str({s!r}).with_name({self.name!r})"

    def __len__(self):
        return len(self.charset)

    def __contains__(self, code):
        return code in self.charset

    def __iter__(self) -> Iterator[int]:
        return iter(self.charset)

    def __le__(self, other: UnicodeSubset) -> bool:
        if not isinstance(other, self.__class__):
            raise TypeError(
                f"unsupported operand type(s) for <=: '{self.__class__.__name__}' and '{type(other).__name__}'"
            )
        return self.charset <= other.charset

    def __lt__(self, other: UnicodeSubset) -> bool:
        if not isinstance(other, self.__class__):
            raise TypeError(
                f"unsupported operand type(s) for <: '{self.__class__.__name__}' and '{type(other).__name__}'"
            )
        return self.charset < other.charset

    def __ge__(self, other: UnicodeSubset) -> bool:
        if not isinstance(other, self.__class__):
            raise TypeError(
                f"unsupported operand type(s) for >=: '{self.__class__.__name__}' and '{type(other).__name__}'"
            )
        return self.charset >= other.charset

    def __gt__(self, other: UnicodeSubset) -> bool:
        if not isinstance(other, self.__class__):
            raise TypeError(
                f"unsupported operand type(s) for >: '{self.__class__.__name__}' and '{type(other).__name__}'"
            )
        return self.charset > other.charset

    def __or__(self, other: Iterable[int]) -> Self:
        if not isinstance(other, self.__class__):
            raise TypeError(
                f"unsupported operand type(s) for |: '{self.__class__.__name__}' and '{type(other).__name__}'"
            )
        return self.union(other)

    def __and__(self, other: Iterable[int]) -> Self:
        if not isinstance(other, self.__class__):
            raise TypeError(
                f"unsupported operand type(s) for &: '{self.__class__.__name__}' and '{type(other).__name__}'"
            )
        return self.intersection(other)

    def __sub__(self, other: Iterable[int]) -> Self:
        if not isinstance(other, self.__class__):
            raise TypeError(
                f"unsupported operand type(s) for -: '{self.__class__.__name__}' and '{type(other).__name__}'"
            )
        return self.difference(iter(other))

    def __ior__(self, other: Iterable[int]):
        if not isinstance(other, self.__class__):
            raise TypeError(
                f"unsupported operand type(s) for |: '{self.__class__.__name__}' and '{type(other).__name__}'"
            )
        self.update(other)

    def __iand__(self, other: Iterable[int]):
        if not isinstance(other, self.__class__):
            raise TypeError(
                f"unsupported operand type(s) for &: '{self.__class__.__name__}' and '{type(other).__name__}'"
            )
        self.intersection_update(other)

    def __isub__(self, other: Iterable[int]):
        if not isinstance(other, self.__class__):
            raise TypeError(
                f"unsupported operand type(s) for -: '{self.__class__.__name__}' and '{type(other).__name__}'"
            )
        self.difference_update(other)


#   █████▒▒█████   ███▄    █ ▄▄▄█████▓     ██████ ▄▄▄█████▓▓██   ██▓ ██▓    ▓█████
# ▓██   ▒▒██▒  ██▒ ██ ▀█   █ ▓  ██▒ ▓▒   ▒██    ▒ ▓  ██▒ ▓▒ ▒██  ██▒▓██▒    ▓█   ▀
# ▒████ ░▒██░  ██▒▓██  ▀█ ██▒▒ ▓██░ ▒░   ░ ▓██▄   ▒ ▓██░ ▒░  ▒██ ██░▒██░    ▒███
# ░▓█▒  ░▒██   ██░▓██▒  ▐▌██▒░ ▓██▓ ░      ▒   ██▒░ ▓██▓ ░   ░ ▐██▓░▒██░    ▒▓█  ▄
# ░▒█░   ░ ████▓▒░▒██░   ▓██░  ▒██▒ ░    ▒██████▒▒  ▒██▒ ░   ░ ██▒▓░░██████▒░▒████▒
#  ▒ ░   ░ ▒░▒░▒░ ░ ▒░   ▒ ▒   ▒ ░░      ▒ ▒▓▒ ▒ ░  ▒ ░░      ██▒▒▒ ░ ▒░▓  ░░░ ▒░ ░
#  ░       ░ ▒ ▒░ ░ ░░   ░ ▒░    ░       ░ ░▒  ░ ░    ░     ▓██ ░▒░ ░ ░ ▒  ░ ░ ░  ░
#  ░ ░   ░ ░ ░ ▒     ░   ░ ░   ░         ░  ░  ░    ░       ▒ ▒ ░░    ░ ░      ░
#            ░ ░           ░                   ░            ░ ░         ░  ░   ░  ░
#                                                           ░ ░
# Provides functionality that maps font widths, weights, and slopes
# from font file names to a structured format.
#

type JSONValue = str | int | float | bool | None | list[JSONValue] | dict[str, JSONValue]
type JSONKey = str | int


@dataclass(frozen=True, kw_only=True)
class StyleMetric:
    name: str
    default_key: str
    fallback_keys: list[str]
    map: dict[str, ...]


@dataclass(frozen=True, kw_only=True, order=True)
class CSSValues:
    # Uses `indices` for sorting key as it is the first field of the dataclass.
    width: str = field(compare=False)
    weight: int = field(compare=False)
    slope: str = field(compare=False)
    indices: tuple[int, int, int]

    def __format__(self, format_spec) -> str:
        if format_spec == "css":
            return f"font-stretch: {self.width}; font-weight: {self.weight}; font-style: {self.slope};"
        raise ValueError(f"Unsupported format specifier: {format_spec!r}")


CONFIG_PREFIX = "buildPlans."
WIDTHS_STYLES = StyleMetric(
    name="widths",
    default_key="Normal",
    fallback_keys=["", "Extended"],
    map={
        "UltraCondensed": "ultra-condensed",
        "ExtraCondensed": "extra-condensed",
        "Condensed": "condensed",
        "SemiCondensed": "semi-condensed",
        "": "normal",
        "Normal": "normal",
        "SemiExtended": "semi-expanded",
        "Extended": "expanded",
        "ExtraExtended": "extra-expanded",
        "UltraExtended": "ultra-expanded",
    },
)
WEIGHTS_STYLES = StyleMetric(
    name="weights",
    default_key="Regular",
    fallback_keys=[
        "Thin",
        "ExtraLight",
        "Light",
        "",
        "Medium",
        "SemiBold",
        "Bold",
        "ExtraBold",
        "Heavy",
    ],
    map={
        "Thin": 100,
        "ExtraLight": 200,
        "Light": 300,
        "SemiLight": 350,
        "": 400,
        "Regular": 400,
        "Book": 450,
        "Medium": 500,
        "SemiBold": 600,
        "Bold": 700,
        "ExtraBold": 800,
        "Heavy": 900,
    },
)
SLOPES_STYLES = StyleMetric(
    name="slopes",
    default_key="Upright",
    fallback_keys=["", "Italic", "Oblique"],
    map={"": "normal", "Upright": "normal", "Italic": "italic", "Oblique": "oblique"},
)


#  _____           _   ____  _         _      ____
# |  ___|__  _ __ | |_/ ___|| |_ _   _| | ___|  _ \ __ _ _ __ ___  ___ _ __
# | |_ / _ \| '_ \| __\___ \| __| | | | |/ _ \ |_) / _` | '__/ __|/ _ \ '__|
# |  _| (_) | | | | |_ ___) | |_| |_| | |  __/  __/ (_| | |  \__ \  __/ |
# |_|  \___/|_| |_|\__|____/ \__|\__, |_|\___|_|   \__,_|_|  |___/\___|_|
#                                |___/


@dataclass(frozen=True, kw_only=True)
class FontStyleParser:
    """
    A parser for font styles (widths, weights, and slopes)
    following the spec in Iosevka build plans configuration.

    It parses a font style string, a PascalCase name in the form of
    "<width><weight><slope>", and maps it to CSS values from the config.
    """

    #: The name of the font plan being processed.
    plan_name: str
    #: A mapping of font width names to corresponding CSS values.
    style_re: re.Pattern[str]
    #: A mapping of font weight names to corresponding integer values.
    widths_map: dict[str, str]
    #: A mapping of font slope names to corresponding CSS values.
    weights_map: dict[str, int]
    #: A regular expression for matching font style strings.
    slopes_map: dict[str, str]

    def css_values(self, font_filename: str) -> CSSValues:
        if font_filename == f"{self.plan_name}-Regular.woff2":
            width, weight, slope = "", "", ""
        else:
            match = self.style_re.fullmatch(font_filename)  # always expected a match
            width, weight, slope = match.group("width", "weight", "slope")
        return CSSValues(
            width=self.widths_map[width],
            weight=self.weights_map[weight],
            slope=self.slopes_map[slope],
            indices=self.get_indices(width, weight, slope),
        )

    def get_indices(self, width_key, weight_key, slope_key) -> tuple[int, int, int]:
        """
        Returns the indices for the given width, weight, and slope keys.
        The indices are used for sorting and ordering the CSS values.
        """
        width_index = list(self.widths_map.keys()).index(width_key)
        weight_index = list(self.weights_map.keys()).index(weight_key)
        slope_index = list(self.slopes_map.keys()).index(slope_key)
        return width_index, weight_index, slope_index

    @classmethod
    def from_build_plan(cls, build_plans: Path, plan_name: str) -> Self:
        with build_plans.open("rb") as f:
            data = tomllib.load(f)

        widths_map = cls.load_style_config(data["buildPlans"], plan_name, WIDTHS_STYLES)
        weights_map = cls.load_style_config(data["buildPlans"], plan_name, WEIGHTS_STYLES)
        slopes_map = cls.load_style_config(data["buildPlans"], plan_name, SLOPES_STYLES)
        metric_re = cls.build_style_re(
            plan_name=plan_name,
            widths=list(widths_map.keys()),
            weights=list(weights_map.keys()),
            slopes=list(slopes_map.keys()),
        )
        return cls(
            plan_name=plan_name,
            style_re=metric_re,
            widths_map=widths_map,
            weights_map=weights_map,
            slopes_map=slopes_map,
        )

    @staticmethod
    def load_style_config(
        config: JSONValue, plan_name: str, metric: StyleMetric
    ) -> dict[str, ...]:
        viewer = JSONViewer(config)
        while True:
            metric_viewer = viewer[plan_name, metric.name]
            if inherits := ~metric_viewer["inherits"]:
                plan_name = FontStyleParser.parse_plan_name(inherits)
            else:
                break
        metric_map = {}
        for key in list(~metric_viewer or metric.fallback_keys):
            value = ~metric_viewer[key, "css"] or metric.map.get(key, key)
            sanitized_key = "" if key == metric.default_key else key
            metric_map[sanitized_key] = value
        return metric_map

    @staticmethod
    def parse_plan_name(qual_plan_name: str) -> str:
        if qual_plan_name.startswith(CONFIG_PREFIX):
            return qual_plan_name.removeprefix(CONFIG_PREFIX)
        raise ValueError("Invalid qualified plan name prefix")

    @staticmethod
    def build_style_re(
        *, plan_name: str, widths: list[str], weights: list[str], slopes: list[str]
    ) -> re.Pattern[str]:
        return re.compile(
            rf"{re.escape(plan_name)}-"
            rf"(?P<width>{"|".join(re.escape(v) for v in widths)})"
            rf"(?P<weight>{"|".join(re.escape(str(v)) for v in weights)})"
            rf"(?P<slope>{"|".join(re.escape(v) for v in slopes)})"
            r"\.woff2"
        )


#  ██░ ██ ▓█████  ██▓     ██▓███  ▓█████  ██▀███    ██████
# ▓██░ ██▒▓█   ▀ ▓██▒    ▓██░  ██▒▓█   ▀ ▓██ ▒ ██▒▒██    ▒
# ▒██▀▀██░▒███   ▒██░    ▓██░ ██▓▒▒███   ▓██ ░▄█ ▒░ ▓██▄
# ░▓█ ░██ ▒▓█  ▄ ▒██░    ▒██▄█▓▒ ▒▒▓█  ▄ ▒██▀▀█▄    ▒   ██▒
# ░▓█▒░██▓░▒████▒░██████▒▒██▒ ░  ░░▒████▒░██▓ ▒██▒▒██████▒▒
#  ▒ ░░▒░▒░░ ▒░ ░░ ▒░▓  ░▒▓▒░ ░  ░░░ ▒░ ░░ ▒▓ ░▒▓░▒ ▒▓▒ ▒ ░
#  ▒ ░▒░ ░ ░ ░  ░░ ░ ▒  ░░▒ ░      ░ ░  ░  ░▒ ░ ▒░░ ░▒  ░ ░
#  ░  ░░ ░   ░     ░ ░   ░░          ░     ░░   ░ ░  ░  ░
#  ░  ░  ░   ░  ░    ░  ░            ░  ░   ░           ░


def rich_string[**P](*args: P.args, end="", **kwargs: P.kwargs) -> str:
    """Rich's print-compatible function that returns a string instead of printing to console."""
    string_io = io.StringIO()
    console = Console(file=string_io, force_terminal=True, highlight=False)
    console.print(*args, end=end, **kwargs)
    return string_io.getvalue()


def error[**P](*args: P.args, status: int = 1, **kwargs: P.kwargs) -> typer.Exit:
    """
    Print an error message to the console and exit the program.
    The caller should raise the value returned by this function.
    """
    print(Text("Error:", style="bold red"), *args, **kwargs)
    return typer.Exit(status)


class JSONViewer:
    """
    A simple viewer for JSON-like structures that allows nested lookups
    and automatically enforces optional chaining.

    A view into the JSON structure can be constructed with `JSONViewer(data)`
    whereas to retrieve the raw data, you can use the `~` operator on the view.
    Chained lookups can be performed using square brackets with comma-separated keys.

    Examples:
        >>> data = {"apple": 1, "banana": {"yellow": 2, "green": 3}}
        >>> viewer = JSONViewer(data)
        >>> viewer["apple"]
        JSONViewer(1)
        >>> ~viewer["apple"]
        1
        >>> viewer["banana", "yellow"]
        JSONViewer(2)
        >>> ~viewer["banana", "yellow"]
        2
        >>> ~viewer["banana"]["red"]
        2
        >>> viewer["banana", "red"]
        JSONViewer(None)
        >>> viewer["banana", "red", "cool"]
        JSONViewer(None)
        >>> ~viewer
        {"apple": 1, "banana": {"yellow": 2, "green": 3}}
    """

    _data: JSONValue

    def __init__(self, value: JSONValue):
        self._data = value

    # noinspection PyArgumentList,PyTypeChecker
    def __getitem__(self, item: JSONKey | tuple[JSONKey, ...]) -> JSONViewer:
        if isinstance(item, tuple):
            return JSONViewer(self._lookup(item))
        else:
            return JSONViewer(self._lookup((item,)))

    def _lookup(self, keys: tuple[JSONKey, ...]) -> JSONValue:
        value = self._data
        for key in keys:
            if isinstance(value, dict):
                if key not in value:
                    return None
                value = value[key]
            elif isinstance(value, list) and isinstance(key, int):
                if key < 0 or key >= len(value):
                    return None
                value = value[key]
        return value

    def __setitem__(self, item: JSONKey | tuple[JSONKey, ...], value: JSONValue):
        raise NotImplementedError("Setting items is not supported in NestedLookup")

    def __repr__(self):
        return f"{type(self).__name__}({self._data!r})"

    def __invert__(self):
        return self._data


if __name__ == "__main__":
    typer_app()
